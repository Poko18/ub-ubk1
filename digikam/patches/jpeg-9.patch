diff -Naur orig/core/libs/dimg/loaders/jpegloader.cpp mod/core/libs/dimg/loaders/jpegloader.cpp
--- orig/core/libs/dimg/loaders/jpegloader.cpp	2013-10-01 08:23:18.000000000 +0200
+++ mod/core/libs/dimg/loaders/jpegloader.cpp	2014-03-24 19:24:02.000000000 +0100
@@ -250,7 +250,7 @@
     }
 
     // read image information
-    jpeg_read_header(&cinfo, true);
+    jpeg_read_header(&cinfo, (boolean)true);
 
     // read dimension (nominal values from header)
     int w = cinfo.image_width;
@@ -300,8 +300,8 @@
     if (m_loadFlags & LoadImageData)
     {
         // set decompression parameters
-        cinfo.do_fancy_upsampling = false;
-        cinfo.do_block_smoothing  = false;
+        cinfo.do_fancy_upsampling = (boolean)false;
+        cinfo.do_block_smoothing  = (boolean)false;
 
         // handle scaled loading
         if (scaledLoadingSize)
@@ -787,8 +787,8 @@
         }
     }
 
-    jpeg_set_quality(&cinfo, quality, true);
-    jpeg_start_compress(&cinfo, true);
+    jpeg_set_quality(&cinfo, quality, (boolean)true);
+    jpeg_start_compress(&cinfo, (boolean)true);
 
     kDebug() << "Using LibJPEG quality compression value: " << quality;
 
diff -Naur orig/core/libs/jpegutils/libjpeg-80/transupp.cpp mod/core/libs/jpegutils/libjpeg-80/transupp.cpp
--- orig/core/libs/jpegutils/libjpeg-80/transupp.cpp	2013-10-01 08:23:17.000000000 +0200
+++ mod/core/libs/jpegutils/libjpeg-80/transupp.cpp	2014-03-24 19:53:57.000000000 +0100
@@ -112,11 +112,11 @@
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, true);
+	 (JDIMENSION) compptr->v_samp_factor, (boolean)true);
       src_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	 dst_blk_y + y_crop_blocks,
-	 (JDIMENSION) compptr->v_samp_factor, false);
+	 (JDIMENSION) compptr->v_samp_factor, (boolean)false);
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,
 			dst_buffer[offset_y],
@@ -158,7 +158,7 @@
 	 blk_y += compptr->v_samp_factor) {
       buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, src_coef_arrays[ci], blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, true);
+	 (JDIMENSION) compptr->v_samp_factor, (boolean)true);
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	/* Do the mirroring */
 	for (blk_x = 0; blk_x * 2 < comp_width; blk_x++) {
@@ -225,11 +225,11 @@
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, true);
+	 (JDIMENSION) compptr->v_samp_factor, (boolean)true);
       src_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	 dst_blk_y + y_crop_blocks,
-	 (JDIMENSION) compptr->v_samp_factor, false);
+	 (JDIMENSION) compptr->v_samp_factor, (boolean)false);
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	dst_row_ptr = dst_buffer[offset_y];
 	src_row_ptr = src_buffer[offset_y];
@@ -290,20 +290,20 @@
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, true);
+	 (JDIMENSION) compptr->v_samp_factor, (boolean)true);
       if (y_crop_blocks + dst_blk_y < comp_height) {
 	/* Row is within the mirrorable area. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
 	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	   comp_height - y_crop_blocks - dst_blk_y -
 	   (JDIMENSION) compptr->v_samp_factor,
-	   (JDIMENSION) compptr->v_samp_factor, false);
+	   (JDIMENSION) compptr->v_samp_factor, (boolean)false);
       } else {
 	/* Bottom-edge blocks will be copied verbatim. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
 	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	   dst_blk_y + y_crop_blocks,
-	   (JDIMENSION) compptr->v_samp_factor, false);
+	   (JDIMENSION) compptr->v_samp_factor, (boolean)false);
       }
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	if (y_crop_blocks + dst_blk_y < comp_height) {
@@ -362,14 +362,14 @@
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, true);
+	 (JDIMENSION) compptr->v_samp_factor, (boolean)true);
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
 	  src_buffer = (*srcinfo->mem->access_virt_barray)
 	    ((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	     dst_blk_x + x_crop_blocks,
-	     (JDIMENSION) compptr->h_samp_factor, false);
+	     (JDIMENSION) compptr->h_samp_factor, (boolean)false);
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
 	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
 	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y + y_crop_blocks];
@@ -418,7 +418,7 @@
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, true);
+	 (JDIMENSION) compptr->v_samp_factor, (boolean)true);
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
@@ -428,13 +428,13 @@
 	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	       comp_width - x_crop_blocks - dst_blk_x -
 	       (JDIMENSION) compptr->h_samp_factor,
-	       (JDIMENSION) compptr->h_samp_factor, false);
+	       (JDIMENSION) compptr->h_samp_factor, (boolean)false);
 	  } else {
 	    /* Edge blocks are transposed but not mirrored. */
 	    src_buffer = (*srcinfo->mem->access_virt_barray)
 	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	       dst_blk_x + x_crop_blocks,
-	       (JDIMENSION) compptr->h_samp_factor, false);
+	       (JDIMENSION) compptr->h_samp_factor, (boolean)false);
 	  }
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
 	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
@@ -499,14 +499,14 @@
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, true);
+	 (JDIMENSION) compptr->v_samp_factor, (boolean)true);
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
 	  src_buffer = (*srcinfo->mem->access_virt_barray)
 	    ((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	     dst_blk_x + x_crop_blocks,
-	     (JDIMENSION) compptr->h_samp_factor, false);
+	     (JDIMENSION) compptr->h_samp_factor, (boolean)false);
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
 	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
 	    if (y_crop_blocks + dst_blk_y < comp_height) {
@@ -570,20 +570,20 @@
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, true);
+	 (JDIMENSION) compptr->v_samp_factor, (boolean)true);
       if (y_crop_blocks + dst_blk_y < comp_height) {
 	/* Row is within the vertically mirrorable area. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
 	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	   comp_height - y_crop_blocks - dst_blk_y -
 	   (JDIMENSION) compptr->v_samp_factor,
-	   (JDIMENSION) compptr->v_samp_factor, false);
+	   (JDIMENSION) compptr->v_samp_factor, (boolean)false);
       } else {
 	/* Bottom-edge rows are only mirrored horizontally. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
 	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	   dst_blk_y + y_crop_blocks,
-	   (JDIMENSION) compptr->v_samp_factor, false);
+	   (JDIMENSION) compptr->v_samp_factor, (boolean)false);
       }
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	dst_row_ptr = dst_buffer[offset_y];
@@ -681,7 +681,7 @@
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, true);
+	 (JDIMENSION) compptr->v_samp_factor, (boolean)true);
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
@@ -691,12 +691,12 @@
 	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	       comp_width - x_crop_blocks - dst_blk_x -
 	       (JDIMENSION) compptr->h_samp_factor,
-	       (JDIMENSION) compptr->h_samp_factor, false);
+	       (JDIMENSION) compptr->h_samp_factor, (boolean)false);
 	  } else {
 	    src_buffer = (*srcinfo->mem->access_virt_barray)
 	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
 	       dst_blk_x + x_crop_blocks,
-	       (JDIMENSION) compptr->h_samp_factor, false);
+	       (JDIMENSION) compptr->h_samp_factor, (boolean)false);
 	  }
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
 	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
@@ -775,9 +775,9 @@
   }
   *result = val;
   if (ptr == *strptr)
-    return false;		/* oops, no digits */
+    return TRUE;		/* oops, no digits */
   *strptr = ptr;
-  return true;
+  return TRUE;
 }
 
 
@@ -797,7 +797,7 @@
 GLOBAL(boolean)
 jtransform_parse_crop_spec (jpeg_transform_info *info, const char *spec)
 {
-  info->crop = false;
+  info->crop = (boolean)false;
   info->crop_width_set = JCROP_UNSET;
   info->crop_height_set = JCROP_UNSET;
   info->crop_xoffset_set = JCROP_UNSET;
@@ -806,14 +806,14 @@
   if (isdigit(*spec)) {
     /* fetch width */
     if (! jt_read_integer(&spec, &info->crop_width))
-      return false;
+      return FALSE;
     info->crop_width_set = JCROP_POS;
   }
   if (*spec == 'x' || *spec == 'X') {	
     /* fetch height */
     spec++;
     if (! jt_read_integer(&spec, &info->crop_height))
-      return false;
+      return FALSE;
     info->crop_height_set = JCROP_POS;
   }
   if (*spec == '+' || *spec == '-') {
@@ -821,20 +821,20 @@
     info->crop_xoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;
     spec++;
     if (! jt_read_integer(&spec, &info->crop_xoffset))
-      return false;
+      return FALSE;
   }
   if (*spec == '+' || *spec == '-') {
     /* fetch yoffset */
     info->crop_yoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;
     spec++;
     if (! jt_read_integer(&spec, &info->crop_yoffset))
-      return false;
+      return FALSE;
   }
   /* We had better have gotten to the end of the string. */
   if (*spec != '\0')
-    return false;
-  info->crop = true;
-  return true;
+    return FALSE;
+  info->crop = (boolean)true;
+  return TRUE;
 }
 
 
@@ -914,14 +914,14 @@
 	  srcinfo->min_DCT_h_scaled_size,
 	  srcinfo->min_DCT_v_scaled_size,
 	  info->transform))
-	return false;
+	return FALSE;
     } else {
       if (!jtransform_perfect_transform(srcinfo->output_width,
 	  srcinfo->output_height,
 	  srcinfo->max_h_samp_factor * srcinfo->min_DCT_h_scaled_size,
 	  srcinfo->max_v_samp_factor * srcinfo->min_DCT_v_scaled_size,
 	  info->transform))
-	return false;
+	return FALSE;
     }
   }
 
@@ -1009,32 +1009,32 @@
   /* Figure out whether we need workspace arrays,
    * and if so whether they are transposed relative to the source.
    */
-  need_workspace = false;
-  transpose_it = false;
+  need_workspace = (boolean)false;
+  transpose_it = (boolean)false;
   switch (info->transform) {
   case JXFORM_NONE:
     if (info->x_crop_offset != 0 || info->y_crop_offset != 0)
-      need_workspace = true;
+      need_workspace = (boolean)true;
     /* No workspace needed if neither cropping nor transforming */
     break;
   case JXFORM_FLIP_H:
     if (info->trim)
       trim_right_edge(info, srcinfo->output_width);
     if (info->y_crop_offset != 0)
-      need_workspace = true;
+      need_workspace = (boolean)true;
     /* do_flip_h_no_crop doesn't need a workspace array */
     break;
   case JXFORM_FLIP_V:
     if (info->trim)
       trim_bottom_edge(info, srcinfo->output_height);
     /* Need workspace arrays having same dimensions as source image. */
-    need_workspace = true;
+    need_workspace = (boolean)true;
     break;
   case JXFORM_TRANSPOSE:
     /* transpose does NOT have to trim anything */
     /* Need workspace arrays having transposed dimensions. */
-    need_workspace = true;
-    transpose_it = true;
+    need_workspace = (boolean)true;
+    transpose_it = (boolean)true;
     break;
   case JXFORM_TRANSVERSE:
     if (info->trim) {
@@ -1042,15 +1042,15 @@
       trim_bottom_edge(info, srcinfo->output_width);
     }
     /* Need workspace arrays having transposed dimensions. */
-    need_workspace = true;
-    transpose_it = true;
+    need_workspace = (boolean)true;
+    transpose_it = (boolean)true;
     break;
   case JXFORM_ROT_90:
     if (info->trim)
       trim_right_edge(info, srcinfo->output_height);
     /* Need workspace arrays having transposed dimensions. */
-    need_workspace = true;
-    transpose_it = true;
+    need_workspace = (boolean)true;
+    transpose_it = (boolean)true;
     break;
   case JXFORM_ROT_180:
     if (info->trim) {
@@ -1058,14 +1058,14 @@
       trim_bottom_edge(info, srcinfo->output_height);
     }
     /* Need workspace arrays having same dimensions as source image. */
-    need_workspace = true;
+    need_workspace = (boolean)true;
     break;
   case JXFORM_ROT_270:
     if (info->trim)
       trim_bottom_edge(info, srcinfo->output_width);
     /* Need workspace arrays having transposed dimensions. */
-    need_workspace = true;
-    transpose_it = true;
+    need_workspace = (boolean)true;
+    transpose_it = (boolean)true;
     break;
   }
 
@@ -1098,14 +1098,14 @@
       width_in_blocks = width_in_iMCUs * h_samp_factor;
       height_in_blocks = height_in_iMCUs * v_samp_factor;
       coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
-	((j_common_ptr) srcinfo, JPOOL_IMAGE, false,
+	((j_common_ptr) srcinfo, JPOOL_IMAGE, (boolean)false,
 	 width_in_blocks, height_in_blocks, (JDIMENSION) v_samp_factor);
     }
     info->workspace_coef_arrays = coef_arrays;
   } else
     info->workspace_coef_arrays = NULL;
 
-  return true;
+  return TRUE;
 }
 
 
@@ -1170,9 +1170,9 @@
 
   /* Discover byte order */
   if (GETJOCTET(data[0]) == 0x49 && GETJOCTET(data[1]) == 0x49)
-    is_motorola = false;
+    is_motorola = (boolean)false;
   else if (GETJOCTET(data[0]) == 0x4D && GETJOCTET(data[1]) == 0x4D)
-    is_motorola = true;
+    is_motorola = (boolean)true;
   else
     return;
 
@@ -1388,7 +1388,7 @@
       GETJOCTET(srcinfo->marker_list->data[4]) == 0 &&
       GETJOCTET(srcinfo->marker_list->data[5]) == 0) {
     /* Suppress output of JFIF marker */
-    dstinfo->write_JFIF_header = false;
+    dstinfo->write_JFIF_header = (boolean)false;
     /* Adjust Exif image parameters */
     if (dstinfo->jpeg_width != srcinfo->image_width ||
 	dstinfo->jpeg_height != srcinfo->image_height)
@@ -1492,25 +1492,25 @@
 			     int MCU_width, int MCU_height,
 			     JXFORM_CODE transform)
 {
-  boolean result = true; /* initialize true */
+  boolean result = (boolean)true; /* initialize true */
 
   switch (transform) {
   case JXFORM_FLIP_H:
   case JXFORM_ROT_270:
     if (image_width % (JDIMENSION) MCU_width)
-      result = false;
+      result = (boolean)false;
     break;
   case JXFORM_FLIP_V:
   case JXFORM_ROT_90:
     if (image_height % (JDIMENSION) MCU_height)
-      result = false;
+      result = (boolean)false;
     break;
   case JXFORM_TRANSVERSE:
   case JXFORM_ROT_180:
     if (image_width % (JDIMENSION) MCU_width)
-      result = false;
+      result = (boolean)false;
     if (image_height % (JDIMENSION) MCU_height)
-      result = false;
+      result = (boolean)false;
     break;
   default:
     break;
