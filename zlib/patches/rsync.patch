diff -Naur orig/deflate.c patched/deflate.c
--- orig/deflate.c	2010-04-20 06:12:21.000000000 +0200
+++ patched/deflate.c	2011-05-04 20:57:49.000000000 +0200
@@ -109,6 +109,17 @@
 #endif
 /* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
 
+#ifndef RSYNC_WIN
+#  define RSYNC_WIN 4096
+#endif
+/* Size of rsync window, must be < MAX_DIST */
+
+#define RSYNC_SUM_MATCH(sum) ((sum) % RSYNC_WIN == 0)
+/* Whether window sum matches magic value */
+
+/* Global rsync mode control variable */
+int zlib_rsync = 0;
+
 /* Values for max_lazy_match, good_match and max_chain_length, depending on
  * the desired pack level (0..9). The values given below have been tuned to
  * exclude worst case performance for pathological files. Better values may be
@@ -194,6 +205,15 @@
     s->head[s->hash_size-1] = NIL; \
     zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
 
+/* ===========================================================================
+ * rsync from env
+ */
+void zlib_rsync_init(void) __attribute((constructor));
+void zlib_rsync_init(void)
+{
+    if (getenv("ZLIB_RSYNC") != NULL) zlib_rsync = 1;
+}
+
 /* ========================================================================= */
 int ZEXPORT deflateInit_(strm, level, version, stream_size)
     z_streamp strm;
@@ -1044,6 +1064,10 @@
     match_init(); /* initialize the asm code */
 #endif
 #endif
+
+    /* rsync params */
+    s->rsync_chunk_end = 0xFFFFFFFFUL;
+    s->rsync_sum = 0;
 }
 
 #ifndef FASTEST
@@ -1334,6 +1358,8 @@
             zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
             s->match_start -= wsize;
             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
+            if (s->rsync_chunk_end != 0xFFFFFFFFUL)
+            s->rsync_chunk_end -= wsize;
             s->block_start -= (long) wsize;
 
             /* Slide the hash table (could be avoided with 32 bit values
@@ -1429,15 +1455,51 @@
     }
 }
 
+local void rsync_roll(s, start, num)
+    deflate_state *s;
+    unsigned start;
+    unsigned num;
+{
+    unsigned i;
+
+    if (start < RSYNC_WIN) {
+	/* before window fills. */
+	for (i = start; i < RSYNC_WIN; i++) {
+	    if (i == start + num) return;
+	    s->rsync_sum += (ulg)s->window[i];
+	}
+	num -= (RSYNC_WIN - start);
+	start = RSYNC_WIN;
+    }
+
+    /* buffer after window full */
+    for (i = start; i < start+num; i++) {
+	/* New character in */
+	s->rsync_sum += (ulg)s->window[i];
+	/* Old character out */
+	s->rsync_sum -= (ulg)s->window[i - RSYNC_WIN];
+	if (s->rsync_chunk_end == 0xFFFFFFFFUL
+            && RSYNC_SUM_MATCH(s->rsync_sum))
+	    s->rsync_chunk_end = i;
+    }
+}
+
+/* ===========================================================================
+ * Set rsync_chunk_end if window sum matches magic value.
+ */
+#define RSYNC_ROLL(s, start, num) \
+   do { if (zlib_rsync) rsync_roll((s), (start), (num)); } while(0)
+
 /* ===========================================================================
  * Flush the current block, with given end-of-file flag.
  * IN assertion: strstart is set to the end of the current match.
  */
-#define FLUSH_BLOCK_ONLY(s, last) { \
+#define FLUSH_BLOCK_ONLY(s, last, pad) { \
    _tr_flush_block(s, (s->block_start >= 0L ? \
                    (charf *)&s->window[(unsigned)s->block_start] : \
                    (charf *)Z_NULL), \
                 (ulg)((long)s->strstart - s->block_start), \
+                (pad), \
                 (last)); \
    s->block_start = s->strstart; \
    flush_pending(s->strm); \
@@ -1445,8 +1507,8 @@
 }
 
 /* Same but force premature exit if necessary. */
-#define FLUSH_BLOCK(s, last) { \
-   FLUSH_BLOCK_ONLY(s, last); \
+#define FLUSH_BLOCK(s, last, pad) { \
+   FLUSH_BLOCK_ONLY(s, last, pad); \
    if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
 }
 
@@ -1497,16 +1559,16 @@
             /* strstart == 0 is possible when wraparound on 16-bit machine */
             s->lookahead = (uInt)(s->strstart - max_start);
             s->strstart = (uInt)max_start;
-            FLUSH_BLOCK(s, 0);
+            FLUSH_BLOCK(s, 0, 0);
         }
         /* Flush if we may have to slide, otherwise block_start may become
          * negative and the data will be gone:
          */
         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
-            FLUSH_BLOCK(s, 0);
+            FLUSH_BLOCK(s, 0, 0);
         }
     }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
+    FLUSH_BLOCK(s, flush == Z_FINISH, 0);
     return flush == Z_FINISH ? finish_done : block_done;
 }
 
@@ -1565,6 +1627,8 @@
 
             s->lookahead -= s->match_length;
 
+            RSYNC_ROLL(s, s->strstart, s->match_length);
+
             /* Insert new strings in the hash table only if the match length
              * is not too large. This saves time but degrades compression.
              */
@@ -1598,12 +1662,17 @@
             /* No match, output a literal byte */
             Tracevv((stderr,"%c", s->window[s->strstart]));
             _tr_tally_lit (s, s->window[s->strstart], bflush);
+            RSYNC_ROLL(s, s->strstart, 1);
             s->lookahead--;
             s->strstart++;
         }
-        if (bflush) FLUSH_BLOCK(s, 0);
+	if (zlib_rsync && s->strstart > s->rsync_chunk_end) {
+	    s->rsync_chunk_end = 0xFFFFFFFFUL;
+	    bflush = 2;
+	}
+        if (bflush) FLUSH_BLOCK(s, 0, bflush-1);
     }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
+    FLUSH_BLOCK(s, flush == Z_FINISH, bflush-1);
     return flush == Z_FINISH ? finish_done : block_done;
 }
 
@@ -1689,6 +1758,7 @@
              */
             s->lookahead -= s->prev_length-1;
             s->prev_length -= 2;
+            RSYNC_ROLL(s, s->strstart, s->prev_length+1);
             do {
                 if (++s->strstart <= max_insert) {
                     INSERT_STRING(s, s->strstart, hash_head);
@@ -1698,7 +1768,11 @@
             s->match_length = MIN_MATCH-1;
             s->strstart++;
 
-            if (bflush) FLUSH_BLOCK(s, 0);
+            if (zlib_rsync && s->strstart > s->rsync_chunk_end) {
+                s->rsync_chunk_end = 0xFFFFFFFFUL;
+                bflush = 2;
+            } 
+            if (bflush) FLUSH_BLOCK(s, 0, bflush-1);
 
         } else if (s->match_available) {
             /* If there was no match at the previous position, output a
@@ -1707,9 +1781,14 @@
              */
             Tracevv((stderr,"%c", s->window[s->strstart-1]));
             _tr_tally_lit(s, s->window[s->strstart-1], bflush);
+            if (zlib_rsync && s->strstart > s->rsync_chunk_end) {
+                s->rsync_chunk_end = 0xFFFFFFFFUL;
+		bflush = 2;
+            } 
             if (bflush) {
-                FLUSH_BLOCK_ONLY(s, 0);
+                FLUSH_BLOCK_ONLY(s, 0, bflush-1);
             }
+            RSYNC_ROLL(s, s->strstart, 1);
             s->strstart++;
             s->lookahead--;
             if (s->strm->avail_out == 0) return need_more;
@@ -1717,7 +1796,14 @@
             /* There is no previous match to compare with, wait for
              * the next step to decide.
              */
+            if (zlib_rsync && s->strstart > s->rsync_chunk_end) {
+                /* Reset huffman tree */
+                s->rsync_chunk_end = 0xFFFFFFFFUL;
+                bflush = 2;
+                FLUSH_BLOCK(s, 0, bflush-1);
+            } 
             s->match_available = 1;
+            RSYNC_ROLL(s, s->strstart, 1);
             s->strstart++;
             s->lookahead--;
         }
@@ -1728,7 +1814,7 @@
         _tr_tally_lit(s, s->window[s->strstart-1], bflush);
         s->match_available = 0;
     }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
+    FLUSH_BLOCK(s, flush == Z_FINISH, bflush-1);
     return flush == Z_FINISH ? finish_done : block_done;
 }
 #endif /* FASTEST */
@@ -1794,9 +1880,9 @@
             s->lookahead--;
             s->strstart++;
         }
-        if (bflush) FLUSH_BLOCK(s, 0);
+        if (bflush) FLUSH_BLOCK(s, 0, 0);
     }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
+    FLUSH_BLOCK(s, flush == Z_FINISH, bflush-1);
     return flush == Z_FINISH ? finish_done : block_done;
 }
 
@@ -1827,8 +1913,8 @@
         _tr_tally_lit (s, s->window[s->strstart], bflush);
         s->lookahead--;
         s->strstart++;
-        if (bflush) FLUSH_BLOCK(s, 0);
+        if (bflush) FLUSH_BLOCK(s, 0, 0);
     }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
+    FLUSH_BLOCK(s, flush == Z_FINISH, bflush-1);
     return flush == Z_FINISH ? finish_done : block_done;
 }
diff -Naur orig/deflate.h patched/deflate.h
--- orig/deflate.h	2010-04-19 06:00:46.000000000 +0200
+++ patched/deflate.h	2011-05-03 20:47:48.000000000 +0200
@@ -267,6 +267,9 @@
      * updated to the new high water mark.
      */
 
+    ulg rsync_sum;      /* rolling sum of rsync window */
+    ulg rsync_chunk_end; /* next rsync sequence point */
+
 } FAR deflate_state;
 
 /* Output a byte on the stream.
@@ -293,7 +296,7 @@
 void ZLIB_INTERNAL _tr_init OF((deflate_state *s));
 int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
 void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,
-                        ulg stored_len, int last));
+                        ulg stored_len, int pad, int last));
 void ZLIB_INTERNAL _tr_align OF((deflate_state *s));
 void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
                         ulg stored_len, int last));
diff -Naur orig/trees.c patched/trees.c
--- orig/trees.c	2010-04-19 06:03:44.000000000 +0200
+++ patched/trees.c	2011-05-04 21:01:34.000000000 +0200
@@ -922,10 +922,11 @@
  * Determine the best encoding for the current block: dynamic trees, static
  * trees or store, and output the encoded block to the zip file.
  */
-void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
+void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, pad, last)
     deflate_state *s;
     charf *buf;       /* input block, or NULL if too old */
     ulg stored_len;   /* length of input block */
+    int pad;          /* pad output to byte boundary */
     int last;         /* one if this is the last block for a file */
 {
     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
@@ -1014,6 +1015,12 @@
 #ifdef DEBUG
         s->compressed_len += 7;  /* align on byte boundary */
 #endif
+#ifdef DEBUG
+    } else if (pad && (s->compressed_len % 8) != 0) {
+#else
+    } else if (pad) {
+#endif
+        _tr_stored_block(s, buf, 0, last);
     }
     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
            s->compressed_len-7*last));
diff -Naur orig/zlib.h patched/zlib.h
--- orig/zlib.h	2010-04-20 06:12:48.000000000 +0200
+++ patched/zlib.h	2011-05-03 20:40:55.000000000 +0200
@@ -1606,6 +1606,9 @@
 ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
 ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
 
+/* Global rsync mode control variable */
+extern int zlib_rsync;
+
 #ifdef __cplusplus
 }
 #endif
